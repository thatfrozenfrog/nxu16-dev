#include "classwiz_bsp.h"
#include "cwx_asm.h"
extern "C"
{
	static void a();
}
#pragma INTERRUPT a 8
#pragma INTERRUPT a 10
#pragma INTERRUPT a 12
#pragma INTERRUPT a 14
#pragma INTERRUPT a 16
#pragma INTERRUPT a 18
#pragma INTERRUPT a 20
#pragma INTERRUPT a 22
#pragma INTERRUPT a 24
#pragma INTERRUPT a 26
#pragma INTERRUPT a 28
#pragma INTERRUPT a 30
#pragma INTERRUPT a 32
#pragma INTERRUPT a 34
#pragma INTERRUPT a 36
#pragma INTERRUPT a 38
#pragma INTERRUPT a 40
#pragma INTERRUPT a 42
#pragma INTERRUPT a 44
#pragma INTERRUPT a 46
#pragma INTERRUPT a 48
#pragma INTERRUPT a 50
#pragma INTERRUPT a 52
#pragma INTERRUPT a 54
#pragma INTERRUPT a 56
#pragma INTERRUPT a 58
#pragma INTERRUPT a 60
extern "C"
{
	static void a() {}
}
void reset_timer()
{
	Timer0Counter = 0;
	Timer0Interval = 0x79e;
	Timer0Control = 0x1;
	InterruptPending_W0 = 0;
	__EI();
}

void delay(ushort after_ticks)
{
	if ((FCON & 2) != 0)
		FCON &= 0xfd;
	__DI();
	Timer0Interval = after_ticks;
	Timer0Counter = 0;
	Timer0Control = 0x0101;
	InterruptPending_W0 = 0;
	StopAcceptor = 0x50;
	StopAcceptor = 0xa0;
	StopControl = 2;
	__asm("nop");
	__asm("nop");
	__EI();
}
void reset_sfrs()
{
	FCON = 0x31;
	BlockControl = 0xf7;
	volatile int i = 0x32;
	while (i--)
	{
	}
	InterruptMask0 = 0x22;
	InterruptMask1 = 0;
	InterruptMask2 = 0;
	val(0xf058) = 0;
	KeyboardInMask = 0;
	ExternalInterruptControl = 0;
	ScreenPower = 7;
	delay(200);
	ScreenRange = 4;
	ScreenBrightness = 7; // 7
	ScreenInterval = 6;
	ScreenUnk1 = 0x17;
	ScreenUnk2 = 8;
	ScreenOffset = 0;
	ScreenMode = 0x17;
	ScreenContrast = 0x12;
	val(0xf220) = 0;
	val(0xf221) = 0x7f;
	val(0xf222) = 0;
	val(0xf223) = 0x7f;
	val(0xf224) = 0;
	val(0xf225) = 0;
	val(0xf048) = 0;
	val(0xf049) = 0;
	val(0xf04a) = 7;
	val(0xf04b) = 0;
	val(0xf04c) = 7;
	val(0xf04e) = 0;
	KeyboardInPullUp = 0;
	KeyboardOut = 0;
	KeyboardOutMask = 0;
}
void reset_screen_sfrs()
{
	ScreenRange = 4;
	ScreenBrightness = 3;
	ScreenInterval = 6;
	ScreenUnk1 = 0x17;
	ScreenUnk2 = 0x8;
	ScreenOffset = 0;
	ScreenMode = 0x15;
}

bool scan_key(kiko __near *er8)
{
	byte r1 = 0x01;
	byte r3 = 0x01;
	byte r2;

	while (r3 <= 0x07)
	{
		KeyboardOut = r1;
		delay(1);
		r2 = KeyboardIn;

		if (r2 == 0xFF)
		{
			r1 <<= 1;
			r3++;
		}
		else
		{
			er8->ko = r1;
			er8->ki = ~r2;
			return 1;
		}
	}

	return r3 <= 0x07;
}
byte key_debounce(kiko __near *er8)
{
	byte r5 = 0x00;
	byte r6 = 0x01;

	while (r6 <= 5)
	{
		delay(10);

		KeyboardOut = er8->ko;
		byte r4 = ~KeyboardIn;

		KeyboardOut = 0;

		if ((r4 & er8->ki) != 0)
		{
			r5++;
			er8->ki &= r4;
		}

		r6++;
	}

	return r5 == 0x05;
}

kiko wait_kiko()
{
	kiko kv;
	bool indicator = 1;
redo:
	ScreenSelect = 0;
	val(0xF803) = 1;
	ScreenSelect = 4;
	val(0xF803) = 1;
	KeyboardOut = 0xff;
	KeyboardInMask = 0xff;
	while (1)
	{
		ScreenSelect = 0;
		val(0xF801) = indicator;
		ScreenSelect = 4;
		val(0xF801) = indicator;
		indicator = !indicator;
		delay(4000);
		if (InterruptPending0 & 2)
		{
			if (scan_key((kiko __near *)&kv))
			{
				key_debounce((kiko __near *)&kv);
				if (kv.ki != 0)
				{
					ScreenSelect = 0;
					val(0xF803) = 1;
					ScreenSelect = 4;
					val(0xF803) = 1;

					return kv;
				}
			}
			goto redo;
		}
	}
}

ushort get_keycode_cpp() {
	ushort keycode = 0;
	byte r1 = 0x01;
	byte r3 = 0x01;

	while (true) {
		val(0xF046) = r1;
		byte r0 = val(0xF040);
		val(0xF046) = 0x00;

		if (r0 != 0xFF) {
			keycode = (r1 << 8) | (r0 ^ 0xFF);
			break;
		}

		r1 <<= 1;
		r3++;
		if (r3 > 0x07) {
			keycode = 0x00;
			break;
		}
	}
	val(0xF046) = 0x00;
	return keycode;
}

ushort wait_keycode()
{
	ushort kv;
	do {
		kv = get_keycode_cpp();
	} while (kv == 0x0000);

	ushort initial_keycode = kv;

	do {
		kv = get_keycode_cpp();
	} while (kv == initial_keycode);

	return initial_keycode;
}


const byte font8x8_basic[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // U+0020 (space)
    0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00,   // U+0021 (!)
    0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // U+0022 (")
    0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00,   // U+0023 (#)
    0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00,   // U+0024 ($)
    0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00,   // U+0025 (%)
    0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00,   // U+0026 (&)
    0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,   // U+0027 (')
    0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00,   // U+0028 (()
    0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00,   // U+0029 ())
    0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,   // U+002A (*)
    0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00,   // U+002B (+)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06,   // U+002C (,)
    0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00,   // U+002D (-)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00,   // U+002E (.)
    0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00,   // U+002F (/)
    0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00,   // U+0030 (0)
    0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00,   // U+0031 (1)
    0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00,   // U+0032 (2)
    0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00,   // U+0033 (3)
    0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00,   // U+0034 (4)
    0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00,   // U+0035 (5)
    0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00,   // U+0036 (6)
    0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00,   // U+0037 (7)
    0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00,   // U+0038 (8)
    0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00,   // U+0039 (9)
    0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00,   // U+003A (:)
    0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06,   // U+003B (;)
    0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00,   // U+003C (<)
    0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00,   // U+003D (=)
    0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00,   // U+003E (>)
    0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00,   // U+003F (?)
    0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00,   // U+0040 (@)
    0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00,   // U+0041 (A)
    0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00,   // U+0042 (B)
    0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00,   // U+0043 (C)
    0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00,   // U+0044 (D)
    0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00,   // U+0045 (E)
    0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00,   // U+0046 (F)
    0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00,   // U+0047 (G)
    0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00,   // U+0048 (H)
    0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // U+0049 (I)
    0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00,   // U+004A (J)
    0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00,   // U+004B (K)
    0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00,   // U+004C (L)
    0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00,   // U+004D (M)
    0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00,   // U+004E (N)
    0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00,   // U+004F (O)
    0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00,   // U+0050 (P)
    0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00,   // U+0051 (Q)
    0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00,   // U+0052 (R)
    0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00,   // U+0053 (S)
    0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // U+0054 (T)
    0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00,   // U+0055 (U)
    0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00,   // U+0056 (V)
    0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00,   // U+0057 (W)
    0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00,   // U+0058 (X)
    0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00,   // U+0059 (Y)
    0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00,   // U+005A (Z)
    0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00,   // U+005B ([)
    0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00,   // U+005C (\)
    0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00,   // U+005D (])
    0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00,   // U+005E (^)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,   // U+005F (_)
    0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,   // U+0060 (`)
    0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00,   // U+0061 (a)
    0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00,   // U+0062 (b)
    0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00,   // U+0063 (c)
    0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00,   // U+0064 (d)
    0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00,   // U+0065 (e)
    0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00,   // U+0066 (f)
    0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F,   // U+0067 (g)
    0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00,   // U+0068 (h)
    0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // U+0069 (i)
    0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E,   // U+006A (j)
    0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00,   // U+006B (k)
    0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // U+006C (l)
    0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00,   // U+006D (m)
    0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00,   // U+006E (n)
    0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00,   // U+006F (o)
    0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F,   // U+0070 (p)
    0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78,   // U+0071 (q)
    0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00,   // U+0072 (r)
    0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00,   // U+0073 (s)
    0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00,   // U+0074 (t)
    0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00,   // U+0075 (u)
    0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00,   // U+0076 (v)
    0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00,   // U+0077 (w)
    0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00,   // U+0078 (x)
    0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F,   // U+0079 (y)
    0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00,   // U+007A (z)
    0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00,   // U+007B ({)
    0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,   // U+007C (|)
    0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00,   // U+007D (})
    0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // U+007E (~)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00    // U+007F
};

/*
void draw_glyph(byte x, byte y, byte chr)
{
	//const auto width = 10;
	//const auto height = 13;
	const auto width = 8;
	const auto height = 8;
	auto wi = width * (byte)chr;
	auto index2 = (wi >> 4);
	auto n = wi & 15;
	auto n2 = (16 - n);
	if (n2 > width)
		n2 = width;
	auto buf = (byte __near *)GetScreenBuffer();
	//auto bs = (ushort *)normal_font + index2 * (height - 1);
	auto bs = (ushort *)font8x8_basic + index2 * (height - 1);
	for (int j = 0; j < height; j++)
	{
		ushort dat = (((bs[index2]) << n) | ((bs[index2 + height]) >> n2)) & 0b1111111000000000;
		byte dat1 = (dat) >> ((x & 7) + 8);
		byte dat2 = (dat) >> ((x & 7));
		buf[(j + 1 + y) * 32 + (x >> 3)] ^= dat1;
		buf[(j + 1 + y) * 32 + (x >> 3) + 1] ^= dat2;

		index2++;
	}
}*/
byte reverse(byte b) {
	b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
	b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
	b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
	return b;
}


void draw_glyph(byte x, byte y, byte chr)
{
    const auto width = 8;
    const auto height = 8;
    
    auto buf = (byte __near *)GetScreenBuffer();
    auto bs = (byte *)font8x8_basic + (chr-0x20) * height;

    for (int j = 0; j < height; j++)
    {
        byte dat = reverse(bs[j]);
        if ((x & 7) == 0) {
            buf[(j + y) * 32 + (x >> 3)] ^= dat;
        }
        else {
            byte dat1 = dat >> (x & 7);
			byte dat2 = dat << (8 - (x & 7));
            buf[(j + y) * 32 + (x >> 3)] ^= dat1;
            buf[(j + y) * 32 + (x >> 3) + 1] ^= dat2;
       }
    }
}


void line_print_n(const char __near *str, byte x, byte y)
{
	while (1)
	{
		byte c = (byte) * (str++);
		if (!c)
			break;
		draw_glyph(x, y, c);
		x += 8;
		if (x > 180)
		{
			x = 0;
			y += 8;
		}
	}
}
void line_print_f(const char *str, byte x, byte y)
{
	while (1)
	{
		byte c = (byte) * (str++);
		if (!c)
			break;
		draw_glyph(x, y, c);
		x += 8;
		if (x > 180)
		{
			x = 0;
			y += 8;
		}
	}
}


void typewrite(const char *str, byte x, byte y, ushort delay_ms)
{
	while (1)
	{
		byte c = (byte) * (str++);
		if (!c)
			break;
		draw_glyph(x, y, c);
		x += 8;
		if (x > 180)
		{
			x = 0;
			y += 8;
		}
		delay(delay_ms);
	}
}

void rect_line(byte y, byte h)
{
	auto buf = (byte __near *)GetScreenBuffer();
	for (byte i = y; i < y + h; i++)
	{
		for (byte j = 0; j <= 31; j++)
		{
			buf[i * 32 + j] ^= 0xff;
		}
	}
}
void rect(byte x, byte y, byte w, byte h)
{
	// Get the base address of the screen buffer
	byte __near *buf1 = (byte __near *)GetScreenBuffer();
	byte __near *buf2 = buf1 + 0x600; // Assuming buf2 is for the second bit plane

	// Precompute the bit position and mask within the byte
	byte startBit = x % 8;
	byte endBit = (x + w) % 8;
	byte startMask = 0xFF >> startBit;
	byte endMask = 0xFF << (8 - endBit);
	byte fullByteCount = (x + w + 7) / 8 - (x / 8) - (startBit != 0);

	// Fill the rectangle in both bit planes
	for (byte i = 0; i < h; ++i)
	{
		// Calculate the starting address of the row in both bit planes
		byte __near *rowStart1 = buf1 + ((y + i) * 32) + (x / 8);
		byte __near *rowStart2 = buf2 + ((y + i) * 32) + (x / 8);

		if (fullByteCount == 0)
		{
			// Case where the rectangle fits within a single byte
			rowStart1[0] |= (startMask & endMask);
			rowStart2[0] |= (startMask & endMask);
		}
		else
		{
			// Case where the rectangle spans multiple bytes
			if (startBit != 0)
			{
				rowStart1[0] |= startMask;
				rowStart2[0] |= startMask;
				rowStart1++;
				rowStart2++;
			}
			for (byte j = 0; j < fullByteCount; ++j)
			{
				rowStart1[j] = 0xFF;
				rowStart2[j] = 0xFF;
			}
			if (endBit != 0)
			{
				rowStart1[fullByteCount] |= endMask;
				rowStart2[fullByteCount] |= endMask;
			}
		}
	}
}
enum KeyCode_2 : ushort
{
	Up = 0xFC00,
	Down,
	Left,
	Right,
	Stdn,
	Ok,
	PgUp,
	PgDn,
	Shift,
	Set,
	Home,
	Back,
	Var,
	Func,
	Ctlg,
	Tools,
	Delete,
	AC,
};
// 竖向: KO 横向: KI
const ushort keymap[]{
	0x0031,
	0x0034,
	0x0037,
	0x0000,
	0x0000,
	Shift,
	Set,
	0x0000,
	0x0032,
	0x0035,
	0x0038,
	0x0000,
	0x0000,
	Var,
	Back,
	Home,
	0x0033,
	0x0036,
	0x0039,
	0x0000,
	0x0000,
	Func,
	Left,
	0x0000,
	0x002B,
	0x0024,
	Delete,
	0x0000,
	0x0000,
	Down,
	Ok,
	Up,
	0x002D,
	0x0026,
	AC,
	0x0000,
	0x0000,
	Ctlg,
	Right,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	Tools,
	PgDn,
	PgUp,
	Ok,
	0x0000,
	0x0000,
	0x0000,
	0x0030,
	0x0000,
	0x0000,
	0x0000,
};
const ushort keymap_shift[]{
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	Shift,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	Left,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	Down,
	Ok,
	Up,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	Right,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	PgDn,
	PgUp,
	Ok,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
};
byte key_mod = 0;
KeyCode getkeycode()
{
	auto key = wait_keycode();
	auto kv = kiko{(byte)(key >> 8), (byte)(key & 0xff)};
	auto km = keymap;
	if (key_mod == 1)
	{
		km = keymap_shift;
	}
	auto s = km[(get_msb(kv.ko) << 3) + get_msb(kv.ki)];
	DebugOutputInt((get_msb(kv.ko) << 3) + get_msb(kv.ki));
	if (s == Shift)
	{
		if (key_mod)
		{
			key_mod = 0;
		}
		else
		{
			key_mod = 1;
		}
		s = 0;
	}
	return (KeyCode)s;
}
